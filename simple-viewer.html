<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Point Cloud | Servionics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0A1628;
            color: white;
            font-family: system-ui, sans-serif;
            overflow: hidden;
        }

        #viewer-container {
            width: 100vw;
            height: 100vh;
        }

        .info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(0, 212, 255, 0.3);
            z-index: 100;
        }

        .info-panel h1 {
            font-size: 18px;
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .info-panel p {
            font-size: 14px;
            color: #8899aa;
            margin: 5px 0;
        }

        .info-panel .value {
            color: #fff;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 212, 255, 0.3);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        <p style="margin-top: 20px; color: #00d4ff;">Lade 3D Punktwolke...</p>
    </div>

    <div class="info-panel" id="info" style="display: none;">
        <h1>üéÆ SERVIONICS 3D Viewer</h1>
        <p>Projekt: <span class="value" id="project-id">-</span></p>
        <p>Punkte: <span class="value" id="point-count">-</span></p>
        <p style="margin-top: 15px; font-size: 12px;">
            üñ±Ô∏è Maus ziehen = Drehen<br>
            üîç Scrollen = Zoom<br>
            ‚å®Ô∏è Shift + Maus = Bewegen
        </p>
    </div>

    <div id="viewer-container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        const BYTES_PER_POINT = 32;
        let scene, camera, renderer, controls;

        // Get project ID from URL
        const params = new URLSearchParams(window.location.search);
        const projectId = params.get('project') || 'demo';
        const splatUrl = `/output/${projectId}/scene.splat`;

        document.getElementById('project-id').textContent = projectId;

        async function init() {
            const container = document.getElementById('viewer-container');

            // Setup THREE.js
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0A1628);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(3, 3, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Add grid
            const gridHelper = new THREE.GridHelper(10, 10, 0x00d4ff, 0x1a3a52);
            scene.add(gridHelper);

            // Load splat
            try {
                const numPoints = await loadSplat(splatUrl);
                document.getElementById('point-count').textContent = numPoints.toLocaleString();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('info').style.display = 'block';
            } catch (error) {
                console.error('Failed to load splat:', error);
                showFallbackCube();
                document.getElementById('loading').innerHTML = '<p style="color: #ff6b6b;">Fehler beim Laden</p>';
            }

            animate();
            window.addEventListener('resize', onResize);
        }

        async function loadSplat(url) {
            console.log('[Viewer] Loading:', url);

            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            const buffer = await response.arrayBuffer();
            const numPoints = Math.floor(buffer.byteLength / BYTES_PER_POINT);

            console.log(`[Viewer] Parsing ${numPoints} points`);

            const positions = new Float32Array(numPoints * 3);
            const colors = new Float32Array(numPoints * 3);
            const view = new DataView(buffer);

            for (let i = 0; i < numPoints; i++) {
                const offset = i * BYTES_PER_POINT;

                // Position (3 floats at offset 0)
                positions[i * 3 + 0] = view.getFloat32(offset + 0, true);
                positions[i * 3 + 1] = view.getFloat32(offset + 4, true);
                positions[i * 3 + 2] = view.getFloat32(offset + 8, true);

                // Color (4 bytes at offset 24)
                colors[i * 3 + 0] = view.getUint8(offset + 24) / 255;
                colors[i * 3 + 1] = view.getUint8(offset + 25) / 255;
                colors[i * 3 + 2] = view.getUint8(offset + 26) / 255;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Custom Gaussian Splat shader for soft, transparent rendering
            const vertexShader = `
                attribute vec3 color;
                varying vec3 vColor;
                
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = 25.0 * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;

            const fragmentShader = `
                varying vec3 vColor;
                
                void main() {
                    vec2 center = gl_PointCoord - vec2(0.5);
                    float dist = length(center);
                    
                    // Gaussian falloff
                    float alpha = exp(-dist * dist * 8.0);
                    if (alpha < 0.01) discard;
                    
                    gl_FragColor = vec4(vColor, alpha * 0.9);
                }
            `;

            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const pointCloud = new THREE.Points(geometry, material);
            scene.add(pointCloud);

            // Center camera
            geometry.computeBoundingSphere();
            if (geometry.boundingSphere) {
                const center = geometry.boundingSphere.center;
                const radius = geometry.boundingSphere.radius || 2;
                controls.target.copy(center);
                camera.position.set(center.x + radius * 2, center.y + radius, center.z + radius * 2);
            }

            return numPoints;
        }

        function showFallbackCube() {
            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00d4ff, wireframe: true });
            scene.add(new THREE.Mesh(geo, mat));
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>

</html>